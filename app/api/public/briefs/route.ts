import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';

/**
 * GET /api/public/briefs
 * 
 * Public endpoint for brief summaries
 * Returns paginated briefs with limited content for free tier
 * 
 * Query params:
 * - page: number (default: 1)
 * - limit: number (default: 12)
 * - type: 'RESEARCH_BRIEF' | 'UPDATE_NOTE' | 'DATA_NOTE' | 'POLICY_NOTE' | 'DOSSIER' | 'all'
 * - search: string (search in title)
 */
export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const page = Math.max(1, parseInt(searchParams.get('page') || '1'));
    const limit = Math.min(50, Math.max(1, parseInt(searchParams.get('limit') || '12')));
    const type = searchParams.get('type') || 'all';
    const search = searchParams.get('search') || '';

    const offset = (page - 1) * limit;

    // Build where clause
    const where: any = {
      status: "PUBLISHED",
      publishedAt: { not: null },
    };

    if (type !== 'all') {
      where.type = type;
    }

    if (search) {
      where.OR = [
        { title: { contains: search, mode: 'insensitive' } },
      ];
    }

    // Get total count for pagination
    const totalCount = await prisma.thinkTankPublication.count({ where });

    // Fetch briefs with summaries
    const briefs = await prisma.thinkTankPublication.findMany({
      where,
      orderBy: { publishedAt: 'desc' },
      skip: offset,
      take: limit,
      select: {
        id: true,
        title: true,
        type: true,
        publishedAt: true,
        wordCount: true,
        sourceIds: true,
        // Generate summary from HTML (first 200 chars)
        html: true,
      },
    });

    // Transform data for public consumption
    const transformedBriefs = briefs.map(brief => {
      // Extract summary from HTML (strip tags, first 200 chars)
      let summary = '';
      try {
        // Simple HTML strip and truncate
        const plainText = brief.html.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();
        summary = plainText.length > 200 ? plainText.substring(0, 200) + '...' : plainText;
      } catch {
        summary = 'Strategic analysis generated by our autonomous think tank.';
      }

      // Estimate read time (200 words per minute)
      const readTime = Math.max(1, Math.ceil(brief.wordCount / 200));

      // Extract topics from title/question (simple keyword extraction)
      const topics: string[] = [];
      try {
        const text = (brief.title || '').toLowerCase();
        const keywords = ['ai', 'climate', 'regulation', 'economy', 'technology', 'policy', 'health', 'energy'];
        keywords.forEach(keyword => {
          if (text.includes(keyword)) {
            topics.push(keyword.charAt(0).toUpperCase() + keyword.slice(1));
          }
        });
      } catch {
        // Ignore errors
      }

      return {
        id: brief.id,
        title: brief.title,
        summary,
        type: brief.type,
        publishedAt: brief.publishedAt?.toISOString() || new Date().toISOString(),
        readTime,
        sources: brief.sourceIds?.length || 0,
        topics: topics.slice(0, 5), // Max 5 topics
        // Map legacy types to new tier names
        tier: brief.type === 'RESEARCH_BRIEF' ? 'EXECUTIVE' : 'STRATEGY',
      };
    });

    const totalPages = Math.ceil(totalCount / limit);

    return NextResponse.json({
      briefs: transformedBriefs,
      pagination: {
        page,
        limit,
        totalCount,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1,
      },
    });

  } catch (error) {
    console.error('[API/Public/Briefs] Error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch briefs' },
      { status: 500 }
    );
  }
}
